diff --git a/sources/libraries/applications/dtectx/main/MainWindow.cpp b/sources/libraries/applications/dtectx/main/MainWindow.cpp
index e5c9ac35350f138869f8141089acc526832041b6..689e304bef969c3911485bf07257e657e27762fa 100644
--- a/sources/libraries/applications/dtectx/main/MainWindow.cpp
+++ b/sources/libraries/applications/dtectx/main/MainWindow.cpp
@@ -50,6 +50,7 @@
 #include "MainToolbarView.h"
 #include "Menu.h"
 #include "MenuSection.h"
+#include "MockUpDockView.h"
 #include "ModelStore.h"
 #include "NotificationsDockView.h"
 #include "NotificationsToolbarView.h"
@@ -498,17 +499,29 @@ void MainWindow::createDocks()
                                                                         ads::LeftDockWidgetArea);
 
     // TOP-RIGHT AREA
+    auto *const topRightDockArea = DocksViewService::createPermanentDock(
+        m_mockUpDockAction,
+        PermanentDock::MockUp,
+        tr("Mock Up"),
+        SvgIcon(ICON_PENCIL_2),
+        new MockUpDockView(),
+        dockManager(),
+        nullptr,
+        ads::CDockWidget::eInsertMode::ForceNoScrollArea,
+        ads::RightDockWidgetArea
+    );
+
     // Toolbox
-    auto *const topRightDockArea = DocksViewService::createPermanentDock(m_toolboxDockAction,
-                                                                         PermanentDock::Toolbox,
-                                                                         tr("Toolbox"),
-                                                                         SvgIcon(ICON_HAMMER),
-                                                                         new ToolboxDockView(this),
-                                                                         dockManager(),
-                                                                         nullptr,
-                                                                         ads::CDockWidget::eInsertMode::
-                                                                         ForceNoScrollArea,
-                                                                         ads::RightDockWidgetArea);
+    DocksViewService::createPermanentDock(
+        m_toolboxDockAction,
+        PermanentDock::Toolbox,
+        tr("Toolbox"),
+        SvgIcon(ICON_HAMMER),
+        new ToolboxDockView(this),
+        dockManager(),
+        topRightDockArea,
+        ads::CDockWidget::eInsertMode::ForceNoScrollArea
+    );
 
     // History
     DocksViewService::createPermanentDock(m_historyDockAction,
@@ -646,6 +659,10 @@ void MainWindow::createViewMenu()
     m_ordersDockAction->setCheckable(true);
     m_viewMenu->addAction(m_ordersDockAction, Menu::ActionOption::DontCloseOnClick);
 
+    m_mockUpDockAction = new QAction(tr("Mock Up"), this);
+    m_mockUpDockAction->setCheckable(true);
+    m_viewMenu->addAction(m_mockUpDockAction, Menu::ActionOption::DontCloseOnClick);
+
     m_devicesDockAction = new QAction(tr("Devices"), this);
     m_devicesDockAction->setCheckable(true);
     m_viewMenu->addAction(m_devicesDockAction, Menu::ActionOption::DontCloseOnClick);
diff --git a/sources/libraries/applications/dtectx/main/MainWindow.h b/sources/libraries/applications/dtectx/main/MainWindow.h
index fe0c355a0273e27782dd5bba1e845d8e1df56451..78fe26bbdf65f3608d34e834fcb225fa4cc61f69 100644
--- a/sources/libraries/applications/dtectx/main/MainWindow.h
+++ b/sources/libraries/applications/dtectx/main/MainWindow.h
@@ -52,6 +52,7 @@ private:
 
     QAction *m_workspaceDockAction{nullptr};
     QAction *m_ordersDockAction{nullptr};
+    QAction *m_mockUpDockAction{nullptr};
     QAction *m_devicesDockAction{nullptr};
     QAction *m_notificationsDockAction{nullptr};
     QAction *m_ordersPropertiesDockAction{nullptr};
diff --git a/sources/libraries/framework/models/docks/DockName.h b/sources/libraries/framework/models/docks/DockName.h
index 15fea471202d7c9f93da76cec0977f7c6ea9effa..763f91955834562eacfed27481e849de9640e574 100644
--- a/sources/libraries/framework/models/docks/DockName.h
+++ b/sources/libraries/framework/models/docks/DockName.h
@@ -12,7 +12,8 @@ enum class PermanentDock
     BackgroundTasks,
     Notifications,
     OrdersProperties,
-    WorkspaceProperties
+    WorkspaceProperties,
+    MockUp
 };
 
 enum class RuntimeDock
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..3eb256260d386917398d1bb21fd66ad4432eebee
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.cpp
@@ -0,0 +1,34 @@
+#include "DockSourceModelsUpdater.h"
+
+#include "MockUpOptionsModel.h"
+
+#include "OptionsService.h"
+
+void DockSourceModelsUpdater::populate(const QVector<Model&> &models) const
+{
+    OptionsService::populate(*m_optionsModel, models);
+}
+
+void DockSourceModelsUpdater::add(Model &model) const
+{
+    OptionsService::add(*m_optionsModel, model);
+}
+
+void DockSourceModelsUpdater::remove(Model &model) const
+{
+    OptionsService::remove(*m_optionsModel, model);
+}
+
+void DockSourceModelsUpdater::clear() const
+{
+    OptionsService::clear(*m_optionsModel);
+}
+
+DockSourceModelsUpdater::DockSourceModelsUpdater():
+    m_optionsModel{std::make_unique<MockUpOptionsModel>()}
+{}
+
+MockUpOptionsModel& DockSourceModelsUpdater::optionsModel() const
+{
+    return *m_optionsModel;
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.h b/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.h
new file mode 100644
index 0000000000000000000000000000000000000000..f77a634db344c04846e97c6a60215b86b6ea1ff6
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/DockSourceModelsUpdater.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "Connector.h"
+
+#include <QObject>
+#include <QVector>
+
+class MockUpOptionsModel;
+class Model;
+
+class Dispatcher : public Connector<QObject>
+{
+Q_OBJECT
+
+protected:
+    CTOR_DEFAULT(Dispatcher)
+};
+
+class DockSourceModelsUpdater : public Dispatcher
+{
+Q_OBJECT
+
+    std::unique_ptr<MockUpOptionsModel> m_optionsModel;
+
+protected:
+    void populate(const QVector<Model&> &models) const;
+    void add(Model &model) const;
+    void remove(Model &model) const;
+    void clear() const;
+
+    template<typename TModel>
+    static QVector<Model&> upcast(std::vector<std::shared_ptr<TModel>> sourceModels)
+    {
+        static_assert(std::is_base_of<Model, TModel>::value, "Source model must be derived from Model");
+
+        auto models = QVector<Model&>{};
+        models.reserve(sourceModels.size());
+
+        for (const auto &sourceModel : sourceModels)
+        {
+            ASSERT(sourceModel != nullptr, "Source model cannot be nullptr")
+            if (sourceModel != nullptr)
+            {
+                models.push_back(*sourceModel);
+            }
+        }
+
+        return models;
+    }
+
+    DockSourceModelsUpdater();
+    ~DockSourceModelsUpdater() override = default;
+    CTOR_NO(DockSourceModelsUpdater)
+
+public:
+    MockUpOptionsModel& optionsModel() const;
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..3586167f3a35d73f58d6b2c35265eb59adef1566
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.cpp
@@ -0,0 +1,105 @@
+#include "GroupNode.h"
+
+#include "MockUpOptionsModel.h"
+
+GroupNode::GroupNode(
+    GroupNode *parent,
+    const std::string &key,
+    const QString &value,
+    const std::vector<std::shared_ptr<MetaModel>> &metaModels
+) :
+    parent{parent},
+    key{key},
+    value{value},
+    row{parent->row + 1},
+    metaModels{metaModels}
+{
+    parent->m_children.push_back(this);
+    setParent(parent);
+}
+
+GroupNode* GroupNode::createRoot(MockUpOptionsModel &parent, const std::vector<std::shared_ptr<MetaModel>> &metaModels)
+{
+    return new GroupNode(parent, metaModels);
+}
+
+GroupNode::GroupNode(MockUpOptionsModel &parent, const std::vector<std::shared_ptr<MetaModel>> &metaModels) :
+    parent{nullptr},
+    value(""),
+    row{0},
+    metaModels{metaModels}
+{
+    parent.setRoot(this);
+    setParent(&parent);
+}
+
+bool GroupNode::isRoot() const
+{
+    ASSERT(!((parent == nullptr) ^ (row == 0)), "If node has no parent, then it's row must be zero and vice versa.")
+    return row == 0 && parent == nullptr;
+}
+
+bool GroupNode::isTerminal() const
+{
+    return m_children.empty();
+}
+
+bool GroupNode::visibility() const
+{
+    return m_visibility;
+}
+
+void GroupNode::setVisibility(bool value)
+{
+    if (m_visibility == value)
+    {
+        return;
+    }
+
+    m_visibility = value;
+
+    emit visibilityChanged(value);
+    emit dataChanged();
+}
+
+bool GroupNode::selected() const
+{
+    return m_selected;
+}
+
+void GroupNode::setSelected(bool value)
+{
+    if (m_selected == value)
+    {
+        return;
+    }
+
+    m_selected = value;
+
+    emit selectedChanged(value);
+    emit dataChanged();
+}
+
+bool GroupNode::expanded() const
+{
+    return m_expanded;
+}
+
+void GroupNode::setExpanded(bool value)
+{
+    if (m_expanded == value)
+    {
+        return;
+    }
+
+    m_expanded = value;
+
+    emit expandedChanged(value);
+    emit dataChanged();
+}
+
+QVector<GroupNode*> GroupNode::children() const
+{
+    const auto lock = lockForRead();
+    return m_children;
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.h b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.h
new file mode 100644
index 0000000000000000000000000000000000000000..74a10de164e7a9a0cd4b54f02390e8020ae54b9f
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNode.h
@@ -0,0 +1,60 @@
+#pragma once
+
+#include "Helper.h"
+
+#include "Model.h"
+
+class MetaModel;
+class MockUpOptionsModel;
+
+class GroupNode final : public Model
+{
+Q_OBJECT
+
+public:
+    GroupNode(
+        GroupNode *parent,
+        const std::string &key,
+        const QString &value,
+        const std::vector<std::shared_ptr<MetaModel>> &metaModels
+    );
+
+    static GroupNode* createRoot(MockUpOptionsModel &parent, const std::vector<std::shared_ptr<MetaModel>> &metaModels);
+
+    ~GroupNode() override = default;
+
+    CTOR_NO(GroupNode)
+
+    const GroupNode *const parent;
+    const std::string key;
+    const QString value;
+    const size_t row;
+    const std::vector<std::shared_ptr<MetaModel>> metaModels;
+
+    [[nodiscard]] bool isRoot() const;
+    [[nodiscard]] bool isTerminal() const;
+
+    [[nodiscard]] bool visibility() const;
+    void setVisibility(bool value);
+
+    [[nodiscard]] bool selected() const;
+    void setSelected(bool value);
+
+    [[nodiscard]] bool expanded() const;
+    void setExpanded(bool value);
+
+    [[nodiscard]] QVector<GroupNode*> children() const;
+
+private:
+    QVector<GroupNode*> m_children;
+    std::atomic_bool m_visibility;
+    std::atomic_bool m_selected;
+    std::atomic_bool m_expanded;
+
+    GroupNode(MockUpOptionsModel &parent, const std::vector<std::shared_ptr<MetaModel>> &metaModels);
+
+signals:
+    void visibilityChanged(bool value) const;
+    void selectedChanged(bool value) const;
+    void expandedChanged(bool value) const;
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..97d93d0a98427758ba6b143f8454ae47e94c35b1
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.cpp
@@ -0,0 +1,78 @@
+#include "GroupNodeView.h"
+
+#include "OrderModel.h"
+
+#include "ExpanderButton.h"
+#include "GroupNode.h"
+
+#include <QLabel>
+#include <QVBoxLayout>
+
+GroupNodeView::GroupNodeView(const MockUpOptionsModel &optionsModel, GroupNode *node) :
+    m_optionsModel{optionsModel},
+    m_node(node),
+    m_contentLayout{new QVBoxLayout()}
+{
+    setLayout(populate());
+}
+
+QLayout* GroupNodeView::populate() const
+{
+    auto *layout = new QVBoxLayout();
+    layout->setContentsMargins(QMargins{});
+
+    if (!m_node->isRoot())
+    {
+        layout->addWidget(createHeader());
+    }
+
+    m_contentLayout->setContentsMargins(QMargins{});
+
+    if (m_node->isTerminal())
+    {
+        for (const auto &metaModel : m_node->metaModels)
+        {
+            m_contentLayout->addWidget(createLeafView(*metaModel));
+        }
+    }
+    else
+    {
+        for (auto &child : m_node->children())
+        {
+            m_contentLayout->addWidget(new GroupNodeView(m_optionsModel, child));
+        }
+    }
+
+    auto *const wrapperLayout = new QHBoxLayout();
+    wrapperLayout->setContentsMargins(QMargins());
+
+    if (!m_node->isRoot())
+    {
+        wrapperLayout->addWidget(new QLabel("-"));
+    }
+
+    wrapperLayout->addLayout(m_contentLayout);
+    layout->addLayout(wrapperLayout);
+    return layout;
+}
+
+QWidget* GroupNodeView::createHeader() const
+{
+    // TODO: new_list: create factory
+    auto *const expander = new ExpanderButton(m_node->value);
+
+    connect(expander,
+            &QPushButton::released,
+            [this]()
+            {
+                m_node->setExpanded(m_node->expanded());
+            });
+
+    return expander;
+}
+
+QWidget* GroupNodeView::createLeafView(MetaModel &metaModel) const
+{
+    // TODO: new_list: create factory
+    return new QLabel(dynamic_cast<OrderModel&>(metaModel).name());
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.h b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.h
new file mode 100644
index 0000000000000000000000000000000000000000..31ba4ab88eef9ba6d9146dd85422fe70d8aa8301
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/GroupNodeView.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "Widget.h"
+
+class GroupNode;
+class QLayout;
+class QVBoxLayout;
+
+class GroupNodeView final : public Widget
+{
+Q_OBJECT
+public:
+    explicit GroupNodeView(const MockUpOptionsModel &optionsModel, GroupNode *node);
+
+private:
+    const MockUpOptionsModel &m_optionsModel;
+    GroupNode *const m_node;
+    QVBoxLayout *const m_contentLayout;
+
+    QLayout* populate() const;
+    QWidget* createHeader() const;
+    QWidget* createLeafView(MetaModel &metaModel) const;
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..eb120f7d9e4df50571da7cf82bfe125a0a503730
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.cpp
@@ -0,0 +1,45 @@
+#include "MockUpContentView.h"
+
+#include "MockUpOptionsModel.h"
+
+#include "OptionsService.h"
+
+#include "Common.h"
+#include "GroupNodeView.h"
+#include "UiUtilities.h"
+
+#include <QScrollArea>
+#include <QVBoxLayout>
+
+MockUpContentView::MockUpContentView(MockUpOptionsModel &optionsModel):
+    m_optionsModel{optionsModel},
+    m_scrollAreaLayout{new QVBoxLayout()}
+{
+    auto *const scrollArea = Common::uiUtilities().wrapInScrollArea(m_scrollAreaLayout);
+
+    auto *const layout = new QVBoxLayout();
+    layout->setContentsMargins(QMargins());
+    layout->addWidget(scrollArea);
+
+    setLayout(layout);
+
+    connect(m_optionsModel,
+            &MockUpOptionsModel::selectedChanged,
+            [this]()
+            {
+                createContent();
+            });
+
+    createContent();
+}
+
+void MockUpContentView::createContent()
+{
+    auto *const root = OptionsService::createGroupTree(m_optionsModel);
+    auto *const rootView = new GroupNodeView(m_optionsModel, root);
+
+    m_scrollAreaLayout->setContentsMargins(QMargins());
+    clearLayout(m_scrollAreaLayout);
+    m_scrollAreaLayout->addWidget(rootView);
+    m_scrollAreaLayout->addStretch(1);
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.h b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.h
new file mode 100644
index 0000000000000000000000000000000000000000..ba87f6758968450413258f7e6db812fab364610a
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpContentView.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "Widget.h"
+
+class MockUpOptionsModel;
+class GroupNode;
+class QVBoxLayout;
+
+class MockUpContentView final : public Widget
+{
+Q_OBJECT
+
+    MockUpOptionsModel &m_optionsModel;
+    QVBoxLayout *const m_scrollAreaLayout;
+
+    void createContent();
+
+public:
+    explicit MockUpContentView(MockUpOptionsModel &optionsModel);
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..58d2885307e10b1b6ddc0d707dde33c8eeb27380
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.cpp
@@ -0,0 +1,110 @@
+#include "MockUpDockHeaderView.h"
+
+#include "Icons.h"
+
+#include "MockUpOptionsModel.h"
+#include "PropertyModel.h"
+
+#include "OptionsService.h"
+
+#include "MenuTitle.h"
+#include "SearchBox.h"
+#include "ToolButton.h"
+
+#include <QHBoxLayout>
+#include <QMenu>
+
+// TODO: new_list: Can be further decomposed into separate widgets
+
+MockUpDockHeaderView::MockUpDockHeaderView(MockUpOptionsModel &optionsModel):
+    m_optionsModel{optionsModel},
+    m_sortButton{new SmallDarkToolButton(ICON_SORT)},
+    m_groupButton{new SmallDarkToolButton(ICON_RECTANGLE_SELECT)},
+    m_searchBox{new SearchBox()}
+{
+    auto *const layout = new QHBoxLayout();
+    layout->setContentsMargins(QMargins());
+    layout->addWidget(m_sortButton);
+    layout->addWidget(m_groupButton);
+    layout->addWidget(m_searchBox);
+    setLayout(layout);
+
+    connect(&m_optionsModel, &MockUpOptionsModel::availableChanged, &MockUpDockHeaderView::onAvailableOptionsChanged);
+    connect(m_searchBox, &SearchBox::textChanged, &MockUpDockHeaderView::onSearchBoxChanged);
+}
+
+void MockUpDockHeaderView::populateGroupMenu() const
+{
+    // TODO: new_list: Reduce code duplication with `populateSortMenu`
+    auto *const menu = new QMenu(m_groupButton);
+    menu->addAction(new MenuTitle(tr("Group By"), menu));
+
+    for (const auto &[key, properties] : m_optionsModel.availableOptions())
+    {
+        ASSERT_FATAL(!properties.empty(),
+                     std::string("Properties for given key should not be empty. Key: " + key).c_str())
+
+        const auto firstProperty = properties[0];
+        auto *const action = new QAction(firstProperty->name(), menu);
+        action->setToolTip(firstProperty->description().value_or(""));
+        action->setWhatsThis(key.c_str());
+        action->setCheckable(true);
+
+        connect(action,
+                &QAction::triggered,
+                [this, key](const bool enabled)
+                {
+                    enabled
+                        ? OptionsService::appendGroupSelectedOption(m_optionsModel, key)
+                        : OptionsService::removeGroupSelectedOption(m_optionsModel, key);
+                });
+
+        menu->addAction(action);
+    }
+
+    m_groupButton->setPopupMode(QToolButton::InstantPopup);
+    m_groupButton->setMenu(menu);
+}
+
+void MockUpDockHeaderView::populateSortMenu() const
+{
+    auto *const menu = new QMenu(m_sortButton);
+    auto *const actionGroup = new QActionGroup(menu);
+    menu->addAction(new MenuTitle(tr("Group By"), menu));
+
+    for (const auto &[key, properties] : m_optionsModel.availableOptions())
+    {
+        ASSERT_FATAL(!properties.empty(),
+                     std::string("Properties for given key should not be empty. Key: " + key).c_str())
+
+        const auto firstProperty = properties[0];
+        auto *const action = new QAction(firstProperty->name(), menu);
+        action->setToolTip(firstProperty->description().value_or(""));
+        action->setWhatsThis(key.c_str());
+        action->setCheckable(true);
+
+        connect(action,
+                &QAction::triggered,
+                [this, key](const bool enabled)
+                {
+                    m_optionsModel.setSelectedSortOption(enabled ? std::make_optional(key) : std::nullopt);
+                });
+
+        actionGroup->addAction(action);
+        menu->addAction(action);
+    }
+
+    m_sortButton->setPopupMode(QToolButton::InstantPopup);
+    m_sortButton->setMenu(menu);
+}
+
+void MockUpDockHeaderView::onSearchBoxChanged(const QString &text) const
+{
+    OptionsService::search(m_optionsModel, text);
+}
+
+void MockUpDockHeaderView::onAvailableOptionsChanged() const
+{
+    populateGroupMenu();
+    populateSortMenu();
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.h b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.h
new file mode 100644
index 0000000000000000000000000000000000000000..633d7ebaae95ed684356813a4ed88bcb5487c88e
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockHeaderView.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "Widget.h"
+
+class MockUpOptionsModel;
+class QToolButton;
+class SearchBox;
+
+class MockUpDockHeaderView final : public Widget
+{
+Q_OBJECT
+
+public:
+    explicit MockUpDockHeaderView(MockUpOptionsModel &optionsModel);
+
+private:
+    MockUpOptionsModel &m_optionsModel;
+    QToolButton *const m_sortButton;
+    QToolButton *const m_groupButton;
+    SearchBox *const m_searchBox;
+
+    void populateGroupMenu() const;
+    void populateSortMenu() const;
+
+private slots:
+    void onAvailableOptionsChanged() const;
+    void onSearchBoxChanged(const QString &text) const;
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..fea26a178746bb98cebfbb6198533782aaedcd7b
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.cpp
@@ -0,0 +1,20 @@
+#include "MockUpDockView.h"
+
+#include "DockSourceModelsUpdater.h"
+#include "MockUpContentView.h"
+#include "MockUpDockHeaderView.h"
+
+#include <QVBoxLayout>
+
+MockUpDockView::MockUpDockView(std::unique_ptr<DockSourceModelsUpdater> sourceUpdater, QWidget *parent):
+    DockWidgetBase{parent},
+    m_sourceUpdater{std::move(sourceUpdater)},
+    m_content{new MockUpContentView(sourceUpdater->optionsModel())},
+    m_header{new MockUpDockHeaderView(sourceUpdater->optionsModel())}
+{
+    auto *const layout = new QVBoxLayout();
+    layout->setContentsMargins(QMargins());
+    layout->addWidget(m_header);
+    layout->addWidget(m_content);
+    setLayout(layout);
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.h b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.h
new file mode 100644
index 0000000000000000000000000000000000000000..0e88d4b46066c7442d60164f25b015d73f982264
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpDockView.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include "Helper.h"
+
+#include "DockWidgetBase.h"
+
+class DockSourceModelsUpdater;
+class MockUpContentView;
+class MockUpDockHeaderView;
+class MockUpOptionsModel;
+class PropertyModel;
+class DockSourceModelsUpdater;
+
+class MockUpDockView final : public DockWidgetBase
+{
+Q_OBJECT
+
+    std::unique_ptr<DockSourceModelsUpdater> m_sourceUpdater;
+    MockUpContentView *const m_content;
+    MockUpDockHeaderView *const m_header;
+
+public:
+    explicit MockUpDockView(std::unique_ptr<DockSourceModelsUpdater> sourceUpdater, QWidget *parent = nullptr);
+    ~MockUpDockView() override = default;
+
+    CTOR_NO(MockUpDockView)
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..15e5f6b009d2969ff35baea9a358bcfcae18edb6
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.cpp
@@ -0,0 +1,97 @@
+#include "MockUpOptionsModel.h"
+
+#include "GroupNode.h"
+
+QVector<Model&> MockUpOptionsModel::sourceModels() const
+{
+    const auto lock = lockForRead();
+    return m_sourceModels;
+}
+
+void MockUpOptionsModel::setSourceModels(QVector<Model&> models)
+{
+    set(&m_sourceModels,
+        &models,
+        [this]()
+        {
+            emit sourceModelsChanged();
+        });
+}
+
+std::map<const std::string, std::vector<std::shared_ptr<PropertyModel>>> MockUpOptionsModel::availableOptions() const
+{
+    const auto lock = lockForRead();
+    return m_availableOptions;
+}
+
+void MockUpOptionsModel::setAvailableOptions(
+    std::map<const std::string, std::vector<std::shared_ptr<PropertyModel>>> availableOptions)
+{
+    set(&m_availableOptions,
+        &availableOptions,
+        [this]()
+        {
+            emit availableChanged();
+        });
+}
+
+std::map<size_t, std::string> MockUpOptionsModel::selectedGroupOptions() const
+{
+    const auto lock = lockForRead();
+    return m_selectedGroupOptions;
+}
+
+void MockUpOptionsModel::setSelectedGroupOptions(std::map<size_t, std::string> selectedOptions)
+{
+    set(&m_selectedGroupOptions,
+        &selectedOptions,
+        [this]()
+        {
+            emit selectedChanged();
+        });
+}
+
+std::optional<std::string> MockUpOptionsModel::selectedSortOption() const
+{
+    const auto lock = lockForRead();
+    return m_selectedSortOption;
+}
+
+void MockUpOptionsModel::setSelectedSortOption(std::optional<std::string> selectedOptions)
+{
+    set(&m_selectedSortOption,
+        &selectedOptions,
+        [this]()
+        {
+            emit selectedChanged();
+        });
+}
+
+void MockUpOptionsModel::setRoot(GroupNode *node)
+{
+    {
+        const auto lock = lockForWrite();
+        if (node == m_root)
+        {
+            return;
+        }
+
+        if (m_root != nullptr)
+        {
+            m_root->deleteLater();
+        }
+    }
+
+    set(&m_root,
+        &node,
+        [this]()
+        {
+            emit rootChanged();
+        });
+}
+
+GroupNode* MockUpOptionsModel::root() const
+{
+    const auto lock = lockForRead();
+    return m_root;
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.h b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.h
new file mode 100644
index 0000000000000000000000000000000000000000..2b3d39e834feec456931f7bc2f7637064490310f
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/MockUpOptionsModel.h
@@ -0,0 +1,53 @@
+#pragma once
+
+#include "Helper.h"
+
+#include "Model.h"
+
+class MetaModel;
+
+struct SelectedOption
+{
+    const std::string key;
+    const size_t index;
+};
+
+// TODO: KM: Consider splitting into GroupTreeModel and HeaderModel
+class MockUpOptionsModel final : public Model
+{
+Q_OBJECT
+
+public:
+    CTOR_DEFAULT(MockUpOptionsModel)
+
+    [[nodiscard]] QVector<Model&> sourceModels() const;
+    void setSourceModels(QVector<Model&> models);
+
+    [[nodiscard]] std::map<const std::string, std::vector<std::shared_ptr<PropertyModel>>> availableOptions() const;
+    void setAvailableOptions(
+        std::map<const std::string, std::vector<std::shared_ptr<PropertyModel>>> availableOptions
+    );
+
+    [[nodiscard]] std::map<size_t, std::string> selectedGroupOptions() const;
+    void setSelectedGroupOptions(std::map<size_t, std::string> selectedOptions);
+
+    [[nodiscard]] std::optional<std::string> selectedSortOption() const;
+    void setSelectedSortOption(std::optional<std::string> selectedOptions);
+
+    void setRoot(GroupNode *node);
+    [[nodiscard]] GroupNode* root() const;
+
+private:
+    QVector<Model&> m_sourceModels;
+    std::map<const std::string, std::vector<std::shared_ptr<PropertyModel>>> m_availableOptions;
+    std::map<size_t, std::string> m_selectedGroupOptions;
+    std::optional<std::string> m_selectedSortOption;
+
+    GroupNode *m_root;
+
+signals:
+    void availableChanged() const;
+    void selectedChanged() const;
+    void sourceModelsChanged() const;
+    void rootChanged() const;
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..950e2a1bf841a373ba0ca9fc51d83c46209b7ad0
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.cpp
@@ -0,0 +1,223 @@
+#include "OptionsService.h"
+
+#include "MockUpOptionsModel.h"
+#include "OrderModel.h"
+
+#include "GroupNode.h"
+
+#include <gsl/gsl_util>
+
+void OptionsService::populate(MockUpOptionsModel &optionsModel,
+                              const std::vector<Model&> &sourceModels)
+{
+    optionsModel.setSourceModels(sourceModels);
+
+    auto propertyMaps = std::vector<std::map<const std::string, std::shared_ptr<PropertyModel>>>{};
+    propertyMaps.reserve(sourceModels.size());
+
+    for (const auto &sourceModel : sourceModels)
+    {
+        propertyMaps.emplace_back(sourceModel->propertyMap());
+    }
+
+    auto keyGroupedProperties = std::map<const std::string, Properties>();
+    auto keyCounts = std::map<std::string, size_t>{};
+    for (const auto &map : propertyMaps)
+    {
+        for (const auto &[key, property] : map)
+        {
+            if (keyGroupedProperties.contains(key))
+            {
+                auto properties = keyGroupedProperties[key];
+                properties.emplace_back(property);
+                keyGroupedProperties[key] = properties;
+            }
+            else
+            {
+                keyGroupedProperties[key] = {property};
+            }
+
+            keyCounts[key] = keyCounts.contains(key) ? ++keyCounts[key] : 1;
+        }
+    }
+
+    auto commonKeyPropertiesMap = std::map<const std::string, Properties>();
+    for (const auto &[key, count] : keyCounts)
+    {
+        if (count == sourceModels.size())
+        {
+            commonKeyPropertiesMap[key] = std::move(keyGroupedProperties[key]);
+        }
+    }
+
+    optionsModel.setAvailableOptions(commonKeyPropertiesMap);
+}
+
+std::vector<std::shared_ptr<Model>> OptionsService::convertOrdersToModels(
+    std::vector<std::shared_ptr<OrderModel>> orders)
+{
+    std::vector<std::shared_ptr<Model>> sourceModels;
+    sourceModels.reserve(orders.size());
+
+    for (const auto &order : orders)
+    {
+        sourceModels.emplace_back(order);
+    }
+
+    return sourceModels;
+}
+
+void OptionsService::appendGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string key)
+{
+    const auto selectedOptions = optionsModel.selectedGroupOptions();
+    auto smallestFreeIndex = 0;
+    for (const auto &[index, key] : selectedOptions)
+    {
+        if (smallestFreeIndex < index)
+        {
+            break;
+        }
+
+        ++smallestFreeIndex;
+    }
+    appendGroupSelectedOption(optionsModel, key, smallestFreeIndex);
+}
+
+void OptionsService::appendGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string key, size_t index)
+{
+    auto selectedOptions = optionsModel.selectedGroupOptions();
+    selectedOptions[index] = key;
+    optionsModel.setSelectedGroupOptions(selectedOptions);
+}
+
+void OptionsService::removeGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string targetKey)
+{
+    auto selectedOptions = optionsModel.selectedGroupOptions();
+
+    auto targetIndex = std::optional<size_t>();
+    for (const auto &[index, key] : selectedOptions)
+    {
+        if (targetKey != key)
+        {
+            continue;
+        }
+
+        targetIndex = index;
+        break;
+    }
+
+    ASSERT(
+        targetIndex.has_value(),
+        std::string("Selected group options does not contain key: " + targetKey).c_str()
+    )
+
+    const auto erasedCount = selectedOptions.erase(targetIndex.value());
+
+    ASSERT(
+        erasedCount < 2,
+        QString("Selected group options must be unique. Grouping, Count: (%1, %2)")
+        .arg(QString::fromStdString(targetKey)).arg(erasedCount)
+        .toStdString().c_str()
+    )
+
+    optionsModel.setSelectedGroupOptions(selectedOptions);
+}
+
+void OptionsService::clearSelectedOptions(MockUpOptionsModel &optionsModel)
+{
+    optionsModel.setSelectedGroupOptions({});
+    optionsModel.setSelectedSortOption(std::nullopt);
+}
+
+GroupNode* OptionsService::createGroupTree(MockUpOptionsModel &optionsModel)
+{
+    auto selectedOptions = optionsModel.selectedGroupOptions();
+
+    auto orderedKeys = QVector<std::string>(gsl::narrow<int>(selectedOptions.size()));
+
+    for (const auto &[index, key] : selectedOptions)
+    {
+        orderedKeys << key;
+    }
+
+    auto *const root = GroupNode::createRoot(optionsModel, optionsModel.sourceModels());
+    createNodes(optionsModel, root, orderedKeys, optionsModel.sourceModels());
+
+    return root;
+}
+
+void OptionsService::search(MockUpOptionsModel &optionsModel, const QString &text)
+{
+    // TODO: new_list: complete
+}
+
+void OptionsService::sort(
+    const MockUpOptionsModel &optionsModel,
+    std::vector<std::shared_ptr<Model>> &unsortedModels
+)
+{
+    const auto selectedSortOption = optionsModel.selectedSortOption();
+
+    if (!selectedSortOption.has_value())
+    {
+        return;
+    }
+
+    std::ranges::sort(unsortedModels.begin(),
+                      unsortedModels.end(),
+                      [&selectedSortOption](auto left, auto right)
+                      {
+                          return left->getPropertyModel(selectedSortOption.value()) <
+                                 right->getPropertyModel(selectedSortOption.value());
+                      });
+}
+
+std::map<QString, std::vector<std::shared_ptr<Model>>> OptionsService::generateValueModelsMap(
+    const std::vector<std::shared_ptr<Model>> &sourceModels,
+    const std::string &key)
+{
+    auto valueModelsMap = std::map<QString, std::vector<std::shared_ptr<Model>>>{};
+    for (const auto &sourceModel : sourceModels)
+    {
+        const auto value = sourceModel->getPropertyModel(key)->getDisplayString();
+        if (valueModelsMap.contains(value))
+        {
+            auto valueModels = valueModelsMap[value];
+            valueModels.emplace_back(sourceModel);
+            valueModelsMap[value] = valueModels;
+        }
+        else
+        {
+            valueModelsMap[value] = {sourceModel};
+        }
+    }
+
+    return valueModelsMap;
+}
+
+void OptionsService::createNodes(
+    const MockUpOptionsModel &optionsModel,
+    GroupNode *parent,
+    QVector<std::string> keys,
+    const std::vector<std::shared_ptr<Model>> &sourceModels
+)
+{
+    if (keys.empty())
+    {
+        return;
+    }
+
+    const auto currentKey = keys.first();
+    keys.pop_front();
+    const auto valueModelsMap = generateValueModelsMap(sourceModels, currentKey);
+    for (const auto &[value, _sourceModels] : valueModelsMap)
+    {
+        auto sourceModelsCopy = _sourceModels;
+        if (keys.empty())
+        {
+            sort(optionsModel, sourceModelsCopy);
+        }
+        auto *const node = new GroupNode(parent, currentKey, value, sourceModelsCopy);
+        createNodes(optionsModel, node, keys, sourceModelsCopy);
+    }
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.h b/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.h
new file mode 100644
index 0000000000000000000000000000000000000000..a610acd886a82ad56f05f578f8f9b1b08abf13bd
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/OptionsService.h
@@ -0,0 +1,46 @@
+#pragma once
+
+#include "Helper.h"
+
+class MockUpOptionsModel;
+class Model;
+class PropertyModel;
+class OrderModel;
+
+class OptionsService final
+{
+CTOR_STATIC(OptionsService)
+
+public:
+    using Properties = QVector<std::shared_ptr<PropertyModel>>;
+
+    static void populate(MockUpOptionsModel &optionsModel, const QVector<Model&> &sourceModels);
+    static void add(MockUpOptionsModel &optionsModel, Model &model);
+    static void remove(MockUpOptionsModel &optionsModel, Model &model);
+    static void clear(MockUpOptionsModel &optionsModel);
+
+    static void appendGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string key);
+    static void appendGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string key, size_t index);
+    static void removeGroupSelectedOption(MockUpOptionsModel &optionsModel, std::string targetKey);
+
+    static void clearSelectedOptions(MockUpOptionsModel &optionsModel);
+
+    static GroupNode* createGroupTree(MockUpOptionsModel &optionsModel);
+
+    static void search(MockUpOptionsModel &optionsModel, const QString &text);
+
+private:
+    static std::map<QString, QVector<Model&>> generateValueModelsMap(
+        const QVector<Model&> &sourceModels,
+        const std::string &key
+    );
+
+    static void createNodes(
+        const MockUpOptionsModel &optionsModel,
+        GroupNode *parent,
+        QVector<std::string> keys,
+        const QVector<Model&> &sourceModels
+    );
+
+    static void sort(const MockUpOptionsModel &optionsModel, QVector<Model&> &unsortedModels);
+};
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.cpp b/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ba351c7519a158480cf6ba2e885f03b33257b7aa
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.cpp
@@ -0,0 +1,40 @@
+#include "OrdersDockSourceUpdater.h"
+
+#include "ModelStore.h"
+#include "OrdersModel.h"
+
+OrdersDockSourceUpdater::OrdersDockSourceUpdater()
+{
+    const auto &orders = ModelStore::get<OrdersModel>();
+
+    populate(upcast(orders.orders()));
+
+    connect(orders,
+            &OrdersModel::added,
+            [this](const auto &order)
+            {
+                ASSERT(order != nullptr, "Order cannot be nullptr")
+                if (order != nullptr)
+                {
+                    add(*order);
+                }
+            });
+
+    connect(orders,
+            &OrdersModel::removed,
+            [this](const auto &order)
+            {
+                ASSERT(order != nullptr, "Order cannot be nullptr")
+                if (order != nullptr)
+                {
+                    remove(*order);
+                }
+            });
+
+    connect(orders,
+            &OrdersModel::cleared,
+            [this]()
+            {
+                clear();
+            });
+}
diff --git a/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.h b/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.h
new file mode 100644
index 0000000000000000000000000000000000000000..75eccfcb70692bf71b598af2f688d4dde4a5b663
--- /dev/null
+++ b/sources/libraries/frontend/docks/permanent/orders/mockup/OrdersDockSourceUpdater.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "DockSourceModelsUpdater.h"
+
+class OrdersDockSourceUpdater final : public DockSourceModelsUpdater
+{
+Q_OBJECT
+
+public:
+    OrdersDockSourceUpdater();
+    ~OrdersDockSourceUpdater() override = default;
+    CTOR_NO(OrdersDockSourceUpdater)
+};
diff --git a/sources/libraries/frontend/viewservices/DocksViewService.h b/sources/libraries/frontend/viewservices/DocksViewService.h
index 45794650be4bc5534b431a3dd90f783b45d52db7..2b0aca168b817e4bafea9caedbb102192f9161e4 100644
--- a/sources/libraries/frontend/viewservices/DocksViewService.h
+++ b/sources/libraries/frontend/viewservices/DocksViewService.h
@@ -24,17 +24,18 @@ class VIEWSERVICES_EXPORT DocksViewService final
 CTOR_STATIC(DocksViewService)
 
 public:
-    static ads::CDockAreaWidget* createPermanentDock(QAction *action,
-                                                     PermanentDock dockType,
-                                                     const QString &dockName,
-                                                     const QIcon &icon,
-                                                     QWidget *childWidget,
-                                                     ads::CDockManager *dockManager,
-                                                     ads::CDockAreaWidget *addDockToAreaWidget,
-                                                     ads::CDockWidget::eInsertMode insertMode =
-                                                             ads::CDockWidget::AutoScrollArea,
-                                                     ads::DockWidgetArea addDockToArea =
-                                                             ads::DockWidgetArea::NoDockWidgetArea, bool isVisible= true);
+    static ads::CDockAreaWidget* createPermanentDock(
+        QAction *action,
+        PermanentDock dockType,
+        const QString &dockName,
+        const QIcon &icon,
+        QWidget *childWidget,
+        ads::CDockManager *dockManager,
+        ads::CDockAreaWidget *addDockToAreaWidget,
+        ads::CDockWidget::eInsertMode insertMode = ads::CDockWidget::AutoScrollArea,
+        ads::DockWidgetArea addDockToArea = ads::DockWidgetArea::NoDockWidgetArea,
+        bool isVisible = true
+    );
 
     static std::shared_ptr<RuntimeDockModel> createRuntimeDock(RuntimeDock dockType,
                                                                const QString &dockName,
diff --git a/sources/libraries/frontend/widgets/expander/ExpanderButton.h b/sources/libraries/frontend/widgets/expander/ExpanderButton.h
index 02fd10f3051fa0322643d56eca514b52efa6dc90..dd0915d711cac4dc421b8bed2127646eba2b71fb 100644
--- a/sources/libraries/frontend/widgets/expander/ExpanderButton.h
+++ b/sources/libraries/frontend/widgets/expander/ExpanderButton.h
@@ -1,9 +1,9 @@
 #pragma once
 
-#include <QPushButton>
-
 #include "Helper.h"
 
+#include <QPushButton>
+
 #include "widgets_export.h"
 
 class WIDGETS_EXPORT ExpanderButton final : public QPushButton
@@ -11,7 +11,7 @@ class WIDGETS_EXPORT ExpanderButton final : public QPushButton
 Q_OBJECT
 
 public:
-    ExpanderButton(const QString &text, QWidget *parent = nullptr);
+    explicit ExpanderButton(const QString &text, QWidget *parent = nullptr);
     ~ExpanderButton() = default;
     CTOR_NO(ExpanderButton)
 };
